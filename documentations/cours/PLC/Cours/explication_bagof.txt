| ?- [user].
compiling user for byte code...
p(1,3,5). p(2,4,1). p(3,5,2). p(4,3,1). p(5,2,4).

user compiled, 2 lines read - 623 bytes written, 2852 ms

(1 ms) yes
| ?- listing(p).

p(1, 3, 5).
p(2, 4, 1).
p(3, 5, 2).
p(4, 3, 1).
p(5, 2, 4).

(1 ms) yes
| ?- bagof(Z, p(X,Y,Z), S).

S = [5]
X = 1
Y = 3 ? ;

S = [1]
X = 2
Y = 4 ? ;

S = [2]
X = 3
Y = 5 ? ;

S = [1]
X = 4
Y = 3 ? ;

S = [4]
X = 5
Y = 2

(1 ms) yes
| ?- bagof(Z,(X,Y)^p(X,Y,Z), S).

S = [5,1,2,1,4]

Le but du prédicat bagof peut avoir la forme T^But qui veut dire : 
résoudre But en excluant des variables libres toutes les variables apparaissant dans le terme T. 
L'opérateur (^)/2 peut être considérée comme un quantificateur existentiel (la lecture logique de X^But étant 
"il existe un X tel que But est vrai").

yes
| ?- bagof(Z,[X,Y]^p(X,Y,Z), S).

S = [5,1,2,1,4]

(1 ms) yes
| ?- bagof(Z,toto(X,Y)^p(X,Y,Z), S).

S = [5,1,2,1,4]

yes
| ?- bagof(Z,(p(X,Y,Z), Z>6), Sac).

no
| ?- findall(Z,(p(X,Y,Z), Z>6), Sac).

Sac = []

findall se distingue de bagof par le fait que : quand le but échoue, l'ensemble des réponses est tout simplement vide.

| ?- setof(Z,[X,Y]^p(X,Y,Z), S).

S = [1,2,4,5]

(1 ms) yes

setof renvoie dans S l'ensemble (donc sans répétition) des solution triées.